{
  parserClass = 'com.rahulrav.baseline.Parser'
  extends = 'com.intellij.extapi.psi.ASTWrapperPsiElement'
  psiPackage = 'com.rahulrav.baseline.psi'
  psiImplPackage = 'com.rahulrav.baseline.psi.impl'
  psiClassPrefix = 'B'
  psiImplClassSuffix = 'Impl'
  tokenTypeClass = 'com.rahulrav.baseline.psi.Token'
  elementTypeClass = 'com.rahulrav.baseline.psi.Element'
  elementTypeHolderClass = 'com.rahulrav.baseline.psi.TokenTypes'
  psiImplUtilClass = 'com.rahulrav.baseline.psi.impl.PsiImplUtils'
  extends('.*stmt$')=statement
  tokens = [
    SLASH = '/'
    SEMI = ';'
    AP = '['
    WILDCARD = '*'
    HY = '-'
    GT = '>'
    LP = '('
    RP = ')'
    SPACE = ' '
    COMMENT_P = 'regexp:[#]'
    ID = 'regexp:[a-zA-Z_$0-9?]'
    NEWLINE = 'regexp:\r\n|\r|\n'
  ]
}

root ::= statement*

statement ::=
    class_stmt
    | method_stmt
    | empty_stmt
    | comment_stmt

class_stmt ::= class_rule NEWLINE
class_rule ::= [
    basic_class_rule |
    class_prefix path_component SLASH match_all |
    class_prefix path_component SLASH WILDCARD
]

basic_class_rule ::= class_prefix path_component SEMI
path_component ::= component ('/'component)*
component ::= ID+
class_prefix ::= 'L'

array_rule ::= AP [ primitives | class_rule ]
argument_rule ::= match_no_args | match_all_args | LP type (',' type)* RP
// Types should only contain the basic class rule.
// Otherwise it gets very ambiguous
type ::= array_rule | basic_class_rule | primitives
primitives ::= 'Z' | 'V' | 'B' | 'S' | 'I'| 'L'| 'F'| 'D'

method_stmt ::= flags method_class_rule method_name argument_rule return_type? NEWLINE
method_class_rule ::= [
    class_prefix path_component SEMI arrow |
    class_prefix path_component SLASH match_all arrow |
    class_prefix path_component SLASH WILDCARD arrow
]
method_name ::= match_all | method_component
method_component ::= [ID+ WILDCARD ID+ | ID+ WILDCARD]
return_type ::= match_all | type

arrow ::= HY GT
match_all ::= WILDCARD WILDCARD
match_no_args ::= LP RP
match_all_args ::= LP WILDCARD WILDCARD RP
flags ::= 'HSP' | 'HS' | 'HP' | 'SP' | 'P' | 'S' | 'H'

comment_stmt ::= COMMENT_P (SPACE | ID)* NEWLINE
empty_stmt ::= NEWLINE
